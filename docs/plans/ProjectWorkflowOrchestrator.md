This is the process that should be coordinated by the ccide-orchestrator-agent. All conversations should be happening in the left panel conversation workpane with the various agents, as coordinated by ccide-orchestrator-agent. When files need to be displayed for review or approval, they should be displayed in the right workpane. If multiple files are to be approved or reviewed, the user should see all files in the right panel footer, as clickable links, listed in alphabetical order. If necessary, allow the footer to scroll left and right to show all entries. Select the left-most button by default, and visually distinguish the active footer button. Clicking on a file button in the footer will deselect what is currently selected, visually identify the new item in the footer, and display the content in the right panel workpane (if it is a viewable filetype). If not viewable, a message will appear in the workpane indicating not viewable.

Note that the user should be kept apprised of what is happening at each step of the process, and all progress should be tracked in the progress file.

1. Begin the Ideation Phase. I've got an idea I want to talk through with you. I'd like you to help me turn it into a fully formed design and spec (docs/plans/spec.md) and eventually an implementation plan. Create a workplan for all of the steps below, then follow each of the workplan steps in order. Store the workplan and progress into docs/plans/ and then begin the workplan.
   
2. Check out the current state of the project in our working directory to understand where we're starting off and what has been done so far. If nothing exists in the directory, ask me what the idea is via the spec-agent agent, and save that to docs/plans/spec.md, then commit and push.
   
3. Now begin the Design Phase. Follow a similar process to define the target audience (docs/plans/icp.md) and user personae for the primary user types (docs/plans/personae.md) via the icp-agent, then commit and push.
   
4. Now use the uiux-design-agent to do the following:
	A. define the pages needed for the app and get user feedback on what changes might be required for each by displaying them in the right panel and asking if they are OK or need changes. Save to docs/plans/pages.md. Commit and push.
	B. Create a pages subfolder at the project root level and put into that a user interactions document for each page listed in docs/plans/pages.md to detail the user interactions that can occur on that page. Name the file userflow-[page].md
	C. Read docs/plans/pages.md and create visual wireframe mockups in the pages subfolder for each page, using plain text characters like | and _ to show panel boundaries, + to show panel corners, etc. Include design rationale commentary under each mockup. Name each file wireframe-[page].md
	D. As wireframes are generated, add their names (without filename extension) to clickable buttons in the right panel footer. When a user clicks one of those buttons, show the corresponding wireframe title in the right panel header and the corresponding file contents in the right panel workpane.
	E. Create a style guide (docs/plans/style-guide.md) for the application. Give user options and record them.
	F. Review the wireframes and generate docs/plans/components-list.md to list all reusable UI elements in the design system (e.g., Header, Buttons, Input Fields, Date Pickers, Form Inputs, Tables, Breadcrumbs, etc.) At the root level of the project, create a subfolder named components. Generate CSS examples of the standard components needed for the application, using the style guide, each in a separate html file in the components subfolder. Display the first of these in the right pane, with clickable titles for all components in the right footer. When a title is clicked, show the file name (without file extension) in the right panel header and the file contents in the right panel workpane. Ask me for approval of each component or update per my requests. Once I sign off, move on to the next step.
	
5. Generate docs/plans/info-architecture.md file as a visual map of how the pages are connected, including a Mermaid.js graph showing page hierarchy and navigation flow. Do this with the arch-design-agent agent Commit and push.

6. Now look at the files created in all steps to date for the application, and define a product requirements document (PRD) via the prd-agent agent. Ask me questions, one at a time, to refine the idea in terms of any functional and nonfunctional requirements not spelled out to date. Ideally, the questions would be multiple choice with lettered answers, but open-ended questions are OK, too. Don't forget: only one question per message. Once you believe you understand what we're doing, stop and describe the design to me, in sections of maybe 200-300 words at a time, asking after each section whether it looks right so far. Save your understanding into docs/plans/prd.md -- then commit and push.
   
7.  Now build a detailed implementation plan for the project, based on the PRD and any other necessary supporting documentation from the project. Assume that the engineers have zero context for our codebase and questionable taste. document everything they need to know. which files to touch for each task, code, testing, docs they might need to check. how to test it.give them the whole plan as bite-sized tasks. DRY. YAGNI. TDD. frequent commits. Assume they are skilled developers, but know almost nothing about our toolset or problem domain. assume they don't know good test design very well. Please write out this plan, in full detail, into docs/plans/

8. This begins the Output Phase. Look at what needs to be built in the implementation plan, and analyze with the swarm-planning-agent agent in order to establish how best to orchestrate the build across multiple parallel agents. Use instances of the coding-agent agent, coordinated by the ccide-orchestrator-agent, to build the final product, including the high-fidelity HTML/CSS for each page of the application and any supporting infrastructure to allow the application to function. Track progress in the progress file. As each page is completed, review the work with the reviewer-agent, and pass any required changes back to the coding agent that is responsible for the work so it can correct mistakes or problems. Use the testing-agent, security-agent, and performance-agent in the same way (review the page, generate feedback and improvement opportunities, review the results, and implement as appropriate).
